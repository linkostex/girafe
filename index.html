<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Giraffe Dash</title>
<style>
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0e1b2a 0%, #14324f 100%);color:#f7f7f7;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
  .wrap{position:relative;height:100%;width:100%}
  .stage{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:0 10px}
  canvas{width:min(100vw,1280px);height:auto;aspect-ratio:16/9;max-height:100vh;background:linear-gradient(#86c8ff 0%, #cfe9ff 40%, #e6f4ff 60%, #f7fbff 100%);border-radius:18px;box-shadow:0 12px 30px rgba(0,0,0,.35);display:block;touch-action:none}
  #hudMini{position:fixed;right:14px;top:10px;z-index:20;display:none;gap:10px;align-items:center}
  .chip{background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.15);padding:8px 12px;border-radius:999px;backdrop-filter:blur(6px)}
  /* Cartoon-styled score without external font */
  #score{
    font-family: "Comic Sans MS", "Trebuchet MS", "Cooper Black", cursive, system-ui;
    font-size: 44px;
    letter-spacing: 0.5px;
    color: #fff;
    text-shadow:
      0 2px 0 #000,
      0 4px 0 #000,
      0 6px 6px rgba(0,0,0,.45);
    transform: skew(-2deg) rotate(-0.5deg);
  }
  #musicBtn{margin-left:8px;border:0;border-radius:999px;padding:8px 12px;background:#ffd166;color:#222;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.35)}
  #centerOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:30}
  #centerCard{min-width:260px;max-width:90vw;background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.2);border-radius:16px;padding:18px 16px;text-align:center;backdrop-filter:blur(6px)}
  #centerCard h2{margin:4px 0 10px}
  .bigbtn{border:0;border-radius:12px;padding:12px 16px;font-weight:800;cursor:pointer;background:#ffd166;color:#1a1a1a;box-shadow:0 8px 22px rgba(0,0,0,.35)}
  #fsBtn{margin-top:8px;background:#c3e8ff}
</style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <canvas id="game" width="960" height="540" aria-label="Giraffe Dash game area" role="img"></canvas>
    </div>
  </div>

  <div id="hudMini" aria-live="polite">
    <div class="chip"><span id="score">0</span></div>
    <button id="musicBtn" aria-pressed="false">ðŸŽµ Musique</button>
  </div>

  <div id="centerOverlay" style="display:flex">
    <div id="centerCard">
      <h2>Giraffe Dash</h2>
      <p>Mobile : <b>droite</b> = sauter Â· <b>gauche</b> = se baisser (maintenir).</p>
      <button class="bigbtn" id="centerPlay">Jouer</button>
      <button class="bigbtn" id="fsBtn">Plein Ã©cran</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hudMini = document.getElementById('hudMini');
  const scoreEl = document.getElementById('score');
  const centerOverlay = document.getElementById('centerOverlay');
  const centerPlay = document.getElementById('centerPlay');
  const fsBtn = document.getElementById('fsBtn');
  const musicBtn = document.getElementById('musicBtn');

  const W = canvas.width, H = canvas.height;

  // --- Gameplay constants & params ---
  const BASE_GROUND = H - 86;
  const G = 2200;
  const JUMP_VY = -820;
  const DUCK_TIME = 240;
  const BASE_SPEED = 300;
  const ACCEL = 28; // px/s^2 continuous
  const MIN_GAP_TIME_BASE = 1.05;
  const CANDY_FREQ = 0.6;
  const COYOTE_TIME = 0.12;
  const JUMP_BUFFER = 0.14;

  // Terrain
  const TERRAIN_AMP = 14;
  const TERRAIN_WAVELEN = 360;
  let terrainPhase = 0;
  function groundYAt(screenX){
    const k = (Math.PI*2)/TERRAIN_WAVELEN;
    return BASE_GROUND + TERRAIN_AMP * Math.sin(k * (screenX + terrainPhase));
  }

  // Player
  const giraffe = { x:140, y:BASE_GROUND, w:70, h:132, vy:0, onGround:true, ducking:false, duckTimer:0, duckLerp:0 };

  // State
  let last = 0, running = false, paused = false;
  let speed = BASE_SPEED, score = 0;
  let entities = [];
  let spawnTimer = 0;
  let timeSinceGrounded = 0;
  let jumpBufferTimer = 0;

  // Pops (+50 animation)
  const pops = [];
  function showPop(x,y,txt){ pops.push({x,y,txt,t:0}); }

  // Scenery
  const clouds = [], farHills = [], trees = [], bushes = [];
  const rnd = (a,b)=> a + Math.random()*(b-a);

  // --- Audio (SFX + BGM) ---
  let audioCtx = null;
  let bgm = null;
  let musicOn = false;
  function ensureAudio(){
    if (!audioCtx){
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
  }
  function sfxJump(){
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(380, now);
    osc.frequency.linearRampToValueAtTime(520, now + 0.12);
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(0.14, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.2);
  }
  function sfxCandy(){
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    let o1 = audioCtx.createOscillator(), g1 = audioCtx.createGain();
    o1.type='triangle'; o1.frequency.setValueAtTime(900, now);
    g1.gain.setValueAtTime(0, now); g1.gain.linearRampToValueAtTime(0.1, now+0.01); g1.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
    o1.connect(g1).connect(audioCtx.destination); o1.start(now); o1.stop(now+0.14);
    let o2 = audioCtx.createOscillator(), g2 = audioCtx.createGain();
    o2.type='triangle'; o2.frequency.setValueAtTime(1200, now+0.07);
    g2.gain.setValueAtTime(0, now+0.07); g2.gain.linearRampToValueAtTime(0.08, now+0.08); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.20);
    o2.connect(g2).connect(audioCtx.destination); o2.start(now+0.07); o2.stop(now+0.22);
  }

  // Upbeat BGM loop (WebAudio) â€” generated live (no assets)
  function startBGM(){
    if (!audioCtx) return;
    if (bgm) return; // already running
    const tempo = 128;
    const spb = 60/tempo;

    const master = audioCtx.createGain();
    master.gain.value = 0.17;
    master.connect(audioCtx.destination);

    // Kick (clicky), Clap on 2 & 4, Hat on off-beats
    function kick(t){
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(45, t+0.15);
      g.gain.setValueAtTime(0.5, t);
      g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
      osc.connect(g).connect(master);
      osc.start(t); osc.stop(t+0.16);
    }
    function clap(t){
      const noise = audioCtx.createBufferSource();
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate*0.12, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.pow(1 - i/data.length, 2.2); }
      const band = audioCtx.createBiquadFilter(); band.type='bandpass'; band.frequency.value=1600; band.Q.value=0.8;
      const g = audioCtx.createGain(); g.gain.setValueAtTime(0.45, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.12);
      noise.buffer = buffer; noise.connect(band); band.connect(g); g.connect(master);
      noise.start(t); noise.stop(t+0.12);
    }
    function hat(t){
      const noise = audioCtx.createBufferSource();
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate*0.05, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.pow(1 - i/data.length, 3); }
      const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
      const g = audioCtx.createGain(); g.gain.setValueAtTime(0.18, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
      noise.buffer = buffer; noise.connect(hp); hp.connect(g); g.connect(master);
      noise.start(t); noise.stop(t+0.05);
    }

    // Bouncy bass (I-V-VI-IV)
    function bass(t, note){
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type='sawtooth';
      osc.frequency.setValueAtTime(note, t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.18, t+0.012);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.22);
      const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=800;
      osc.connect(lp).connect(g).connect(master);
      osc.start(t); osc.stop(t+0.24);
    }

    // Plucky lead on offbeats
    function lead(t, note){
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type='triangle';
      osc.frequency.setValueAtTime(note, t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.12, t+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=400;
      osc.connect(hp).connect(g).connect(master);
      osc.start(t); osc.stop(t+0.14);
    }

    const root = 196; // G3
    const scale = [0, 7, 9, 5]; // I V VI IV

    let next = audioCtx.currentTime + 0.05;
    let step = 0;
    const ahead = 0.25;
    const interval = 25;

    function scheduler(){
      while (next < audioCtx.currentTime + ahead){
        const pos = step % 8;     // half-beat steps per bar
        const bar = Math.floor(step / 8);
        // Drums
        kick(next);
        if (pos === 2 || pos === 6) clap(next);
        if (pos % 2 === 1) hat(next);
        // Bass
        const chord = scale[bar % 4];
        const bassNote = root * Math.pow(2, chord/12);
        bass(next, bassNote);
        // Lead on offbeats
        if (pos % 2 === 1){
          const leadNote = root*2 * Math.pow(2, (12 + (pos===1?0:pos===3?2:pos===5?4:7))/12);
          lead(next, leadNote);
        }
        next += (60/128)/2; // half-beat
        step++;
      }
      bgm.timer = setTimeout(scheduler, interval);
    }

    bgm = { timer:null, stop(){
      if (this.timer) clearTimeout(this.timer);
      this.timer=null; master.disconnect(); bgm=null;
    }};
    scheduler();
  }

  function toggleMusic(){
    ensureAudio();
    if (!musicOn){
      startBGM();
      musicOn = true;
      musicBtn.setAttribute('aria-pressed','true');
      musicBtn.textContent = 'ðŸ”‡ Couper la musique';
    }else{
      if (bgm) bgm.stop();
      musicOn = false;
      musicBtn.setAttribute('aria-pressed','false');
      musicBtn.textContent = 'ðŸŽµ Musique';
    }
  }
  musicBtn.addEventListener('click', toggleMusic);

  async function goFullscreen(){
    const el = document.documentElement;
    try{
      if (!document.fullscreenElement){
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      }
    }catch(e){}
  }
  fsBtn.addEventListener('click', ()=> goFullscreen());

  function startGame(){
    ensureAudio();
    hudMini.style.display = 'flex';
    centerOverlay.style.display = 'none';
    if (!musicOn){ toggleMusic(); } // auto-start music on first play (user gesture)
    score = 0; speed = BASE_SPEED; entities.length = 0;
    terrainPhase = 0;
    giraffe.y = groundYAt(giraffe.x); giraffe.vy = 0; giraffe.onGround = true; giraffe.ducking=false; giraffe.duckTimer=0; giraffe.duckLerp=0; giraffe.h=132;
    timeSinceGrounded = 0; jumpBufferTimer = 0;
    pops.length = 0;
    clouds.length = 0; farHills.length = 0; trees.length = 0; bushes.length = 0;
    seedScenery();
    spawnTimer = 0;
    running = true; paused = false; last = performance.now();
    requestAnimationFrame(loop);
  }

  function endGame(){
    running = false;
    hudMini.style.display = 'none';
    centerOverlay.style.display = 'flex';
    const card = document.getElementById('centerCard');
    const old = document.getElementById('statsInfo'); if (old) old.remove();
    const info = document.createElement('div'); info.id='statsInfo'; info.style.margin='6px 0 10px'; info.textContent = 'Score: ' + Math.floor(score);
    card.appendChild(info);
  }

  function seedScenery(){
    for (let i=0;i<6;i++) clouds.push({x:rnd(0,W), y:rnd(40,160), s:rnd(0.6,1.2)});
    for (let i=0;i<5;i++) farHills.push({x:i*260, w:rnd(220,300), h:rnd(46,72)});
    for (let i=0;i<6;i++) trees.push({x:rnd(0,W), y:BASE_GROUND, s:rnd(0.9,1.2)});
    for (let i=0;i<8;i++) bushes.push({x:rnd(0,W), y:BASE_GROUND, s:rnd(0.8,1.1)});
  }

  // Touch controls
  function pointerSideFromTouch(t){
    const rect = canvas.getBoundingClientRect();
    const relX = (t.clientX - rect.left) / rect.width;
    return relX > 0.5 ? 'right' : 'left';
  }
  canvas.addEventListener('touchstart', (e)=>{
    ensureAudio();
    for (const t of e.changedTouches){
      const side = pointerSideFromTouch(t);
      if (side === 'right') pressJump();
      else setDuck(true);
    }
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('touchend', (e)=>{ setDuck(false); e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchcancel', ()=> setDuck(false), {passive:false});

  // Keyboard (desktop)
  window.addEventListener('keydown', (e)=>{
    if (['ArrowUp','Space','ArrowDown','KeyP','Enter'].includes(e.code)) e.preventDefault();
    if (e.code==='Enter' && !running){ startGame(); return; }
    ensureAudio();
    if (e.code==='ArrowUp' || e.code==='Space') pressJump();
    if (e.code==='ArrowDown') setDuck(true);
    if (e.code==='KeyP') togglePause();
  }, {passive:false});
  window.addEventListener('keyup', (e)=>{ if (e.code==='ArrowDown') setDuck(false); }, {passive:false});

  centerPlay.addEventListener('click', ()=> startGame());

  function pressJump(){
    if (!running || paused) return;
    jumpBufferTimer = JUMP_BUFFER;
    tryPerformJump(true);
  }
  function tryPerformJump(withSfx=false){
    if (giraffe.onGround || timeSinceGrounded < COYOTE_TIME){
      giraffe.vy = JUMP_VY;
      giraffe.onGround = false;
      jumpBufferTimer = 0;
      if (withSfx) sfxJump();
    }
  }
  function setDuck(state){
    if (!running || paused) return;
    if (state){
      if (!giraffe.ducking){ giraffe.ducking = true; giraffe.duckTimer = Date.now(); }
    } else {
      if(Date.now() - giraffe.duckTimer > DUCK_TIME){ giraffe.ducking = false; }
    }
  }
  function togglePause(){ if (!running) return; paused = !paused; if (!paused){ last = performance.now(); requestAnimationFrame(loop); } }

  // Difficulty / pacing
  function minGapTime(){
    const factor = Math.min(0.5, (speed-BASE_SPEED)/700);
    return Math.max(0.7, MIN_GAP_TIME_BASE - factor);
  }

  function spawnObstacle(){
    const isBird = Math.random() < 0.45;
    const atX = W + 40;
    if (isBird){
      const groundHere = groundYAt(atX);
      const flightH = 60 + (Math.random()*12+12);
      const bird = {kind:'ob', type:'bird', x: atX, w: 54, h: 30, t: 0, hit:false, offset: flightH};
      bird.y = groundHere - bird.h - flightH;
      entities.push(bird);
    } else {
      const h = (Math.random()*16+48);
      const w = h * (Math.random()*0.5+1.3);
      const groundHere = groundYAt(atX);
      const rock = {kind:'ob', type:'rock', x: atX, w, h, hit:false, groundAttach:true};
      rock.y = groundHere - h + 4;
      entities.push(rock);
    }
    if (Math.random() < CANDY_FREQ){
      const size = 32;
      const aerial = Math.random() < 0.5;
      const groundHere = groundYAt(atX);
      const y = aerial ? groundHere - 90 - (Math.random()*30-10) : groundHere - size;
      entities.push({kind:'candy', x: atX + (Math.random()*80+120), y, w:size, h:size, taken:false, t:0});
    }
    spawnTimer = (Math.random()*(minGapTime()*0.3) + minGapTime());
  }

  function loop(ts){
    if (!running || paused) return;
    const dt = Math.min(32, ts - last) / 1000;
    last = ts;

    // Continuous acceleration
    speed += ACCEL * dt;

    terrainPhase += speed * dt * 0.6;

    giraffe.vy += G * dt;
    giraffe.y += giraffe.vy * dt;

    // buffered jump
    jumpBufferTimer -= dt;
    if (jumpBufferTimer > 0) tryPerformJump(false);

    const targetLerp = giraffe.ducking ? 1 : 0;
    giraffe.duckLerp += (targetLerp - giraffe.duckLerp) * Math.min(1, 10*dt);

    const standH = 132, duckH = 58;
    const targetHeight = standH*(1-giraffe.duckLerp) + duckH*giraffe.duckLerp;
    giraffe.h += (targetHeight - giraffe.h) * Math.min(1, 14*dt);

    const localGround = groundYAt(giraffe.x);
    if (giraffe.y > localGround){ giraffe.y = localGround; giraffe.vy = 0; giraffe.onGround = true; } else { giraffe.onGround = false; }
    if (giraffe.onGround){ timeSinceGrounded = 0; } else { timeSinceGrounded += dt; }

    // spawn
    spawnTimer -= dt;
    if (spawnTimer <= 0) spawnObstacle();

    // move & collisions
    for (let i=entities.length-1;i>=0;i--){
      const e = entities[i];
      if (e.kind==='ob' && e.type==='bird'){ e.t += dt; }
      if (e.kind==='candy'){ e.t += dt; }
      e.x -= speed * dt;
      if (e.groundAttach){ e.y = groundYAt(e.x) - e.h + 4; }
      if (e.type==='bird'){ e.y = groundYAt(e.x) - e.h - e.offset; }

      // refined hitboxes
      const playerBox = insetRect({x:giraffe.x, y:giraffe.y - giraffe.h, w:giraffe.w, h:giraffe.h}, 12, 16, 10, 8);
      let obBox = e;
      if (e.kind==='ob'){
        if (e.type==='rock'){
          obBox = insetRect({x:e.x, y:e.y, w:e.w, h:e.h}, 6, 12, 0, 0);
        } else if (e.type==='bird'){
          obBox = insetRect({x:e.x, y:e.y, w:e.w, h:e.h}, 10, 8, 6, 6);
        }
        if (rectsOverlap(playerBox, obBox)){
          endGame();
        }
      } else if (e.kind==='candy'){
        if (!e.taken && rectsOverlap(playerBox, e)){
          e.taken = true; score += 50; showPop(e.x, e.y, '+50'); sfxCandy();
        }
      }
      if (e.x < -200 || e.taken){ entities.splice(i,1); }
    }

    // score scales a bit with speed
    score += 0.5 * (speed/BASE_SPEED);

    draw(dt);
    scoreEl.textContent = Math.floor(score);

    if (running) requestAnimationFrame(loop);
  }

  function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  function insetRect(r, left, top, right, bottom){
    return { x: r.x + left, y: r.y + top, w: r.w - left - right, h: r.h - top - bottom };
  }

  // --- Rendering ---
  const popsFont = 'bold 14px system-ui';
  function drawPops(){
    for (let i=pops.length-1;i>=0;i--){
      const p = pops[i];
      p.t += 0.016;
      p.y -= 36*0.016;
      const alpha = Math.max(0, 1 - p.t*1.6);
      if (p.t > 0.9){ pops.splice(i,1); continue; }
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#222';
      ctx.fillRect(p.x-18, p.y-26, 46, 22);
      ctx.fillStyle = '#fff';
      ctx.font = popsFont;
      ctx.fillText(p.txt, p.x-10, p.y-10);
      ctx.restore();
    }
  }
  function drawCandy(e){
    const t = e.t || 0;
    const pulse = 1 + Math.sin(t*6)*0.06;
    ctx.save(); ctx.translate(e.x+e.w/2, e.y+e.h/2); ctx.scale(pulse, pulse); ctx.rotate(Math.sin(t*2)*0.12);
    const grad = ctx.createLinearGradient(-10,-10,10,10);
    grad.addColorStop(0,'#ff8282'); grad.addColorStop(0.5,'#ff4d4d'); grad.addColorStop(1,'#c71f1f');
    ctx.fillStyle = grad;
    roundRectPath(-e.w/2,-e.h/2,e.w,e.h,6); ctx.fill();
    ctx.globalAlpha=0.35; ctx.fillStyle='#fff'; roundRectPath(-4,-10,6,12,3); ctx.fill(); ctx.globalAlpha=1;
    ctx.fillStyle = '#ffd166';
    ctx.beginPath(); ctx.moveTo(-e.w/2-6,-6); ctx.lineTo(-e.w/2, -2); ctx.lineTo(-e.w/2, 2); ctx.lineTo(-e.w/2-6, 6); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(e.w/2+6,-6); ctx.lineTo(e.w/2, -2); ctx.lineTo(e.w/2, 2); ctx.lineTo(e.w/2+6, 6); ctx.closePath(); ctx.fill();
    ctx.restore();
  }
  function drawRock(e){
    const cx = e.x + e.w*0.5, cy = e.y + e.h*0.6;
    const r = Math.min(e.w,e.h)*0.55;
    const grad = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r*1.2);
    grad.addColorStop(0,'#a2b1bf'); grad.addColorStop(1,'#6a7884');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(cx, e.y + e.h*0.7, r*1.1, r*0.8, 0, 0, Math.PI*2);
    ctx.ellipse(cx - r*0.7, e.y + e.h*0.65, r*0.65, r*0.5, 0.2, 0, Math.PI*2);
    ctx.ellipse(cx + r*0.7, e.y + e.h*0.62, r*0.6, r*0.45, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.beginPath(); ctx.ellipse(cx - r*0.2, e.y + e.h*0.52, r*0.25, r*0.15, -0.3, 0, Math.PI*2); ctx.fill();
  }
  function drawBird(e){
    const flap = Math.sin(e.t*10);
    const cx = e.x + e.w/2, cy = e.y + e.h/2;
    ctx.fillStyle = '#0e0e0e';
    ctx.beginPath(); ctx.ellipse(cx, cy, e.w*0.45, e.h*0.55, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx+12, cy-6, 9, 7, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffc94d'; ctx.beginPath(); ctx.moveTo(cx+20, cy-6); ctx.lineTo(cx+30, cy-2); ctx.lineTo(cx+20, cy+2); ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#181818';
    ctx.save(); ctx.translate(cx-6, cy-2); ctx.rotate(-0.2 + flap*0.25); wingShape(0,0, e.w*0.7, e.h*0.7); ctx.restore();
    ctx.save(); ctx.translate(cx-6, cy-2); ctx.scale(1,-1); ctx.rotate(-0.2 + flap*0.25); wingShape(0,0, e.w*0.7, e.h*0.7); ctx.restore();
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx+14, cy-8, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(cx+14, cy-8, 1.1, 0, Math.PI*2); ctx.fill();
  }
  function drawGiraffe(){
    const x = giraffe.x, y = giraffe.y;
    const h = giraffe.h, w = giraffe.w;
    const base = '#f2c14e', spot = '#a46a28', light = '#f7d98a';
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.18)';
    ctx.beginPath(); ctx.ellipse(x + w/2, groundYAt(x)+10, 32, 8 + Math.max(0, 10*(1-giraffe.duckLerp)), 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(x, y);
    const neckAngle = -0.05 + giraffe.duckLerp * 0.65;
    const neckLen = h*0.75;
    const torsoH = h*0.55;
    const torsoW = w*0.75;
    const torsoY = -torsoH;

    ctx.fillStyle = base;
    roundRectPath(0, torsoY, torsoW, torsoH, 14); ctx.fill();

    ctx.save();
    ctx.translate(torsoW*0.62, torsoY+6);
    ctx.rotate(neckAngle);
    roundRectPath(0, -neckLen, 18, neckLen, 9);
    ctx.fillStyle = base; ctx.fill();
    ctx.fillStyle = spot;
    for (let i=0;i<7;i++){ ctx.fillRect(2, -neckLen + i*(neckLen/7), 4, 8); }
    ctx.translate(26, -neckLen+18);
    roundRectPath(-14, -16, 32, 22, 8); ctx.fillStyle = base; ctx.fill();
    ctx.fillStyle = light; roundRectPath(4, -10, 14, 14, 6); ctx.fill();
    ctx.fillStyle = light; roundRectPath(10, -22, 8, 10, 4); ctx.fill();
    ctx.fillStyle = spot; roundRectPath(-2, -22, 3, 12, 2); ctx.fill(); roundRectPath(6, -24, 3, 12, 2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(6, -8, 3.2, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(6.6, -8, 1.6, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.fillStyle = base; roundRectPath(-10, torsoY+torsoH*0.65, 18, 6, 3); ctx.fill();
    ctx.fillStyle = spot; ctx.beginPath(); ctx.arc(-12, torsoY+torsoH*0.68, 4, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = base;
    roundRectPath(torsoW*0.12, -16, 10, 16, 4); ctx.fill();
    roundRectPath(torsoW*0.32, -16, 10, 16, 4); ctx.fill();

    ctx.globalAlpha = 0.35; ctx.fillStyle = light; ctx.beginPath(); ctx.ellipse(torsoW*0.4, -torsoH*0.4, 26, 16, -0.2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1;

    ctx.fillStyle = spot; ctx.globalAlpha = 0.95;
    paintSpot(torsoW*0.18, -torsoH*0.2, 14,10);
    paintSpot(torsoW*0.36, -torsoH*0.28, 12,9);
    paintSpot(torsoW*0.52, -torsoH*0.16, 10,8);
    paintSpot(torsoW*0.10, -torsoH*0.34, 12,9);
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function drawGroundStrip(){
    const steps = 32;
    ctx.beginPath();
    ctx.moveTo(0, H);
    for (let i=0;i<=steps;i++){
      const sx = (i/steps)*W;
      const gy = groundYAt(sx);
      ctx.lineTo(sx, gy);
    }
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fillStyle = '#c9f082'; ctx.fill();
    ctx.strokeStyle = '#96dd6b'; ctx.lineWidth = 6; ctx.beginPath();
    for (let i=0;i<=steps;i++){
      const sx = (i/steps)*W;
      const gy = groundYAt(sx);
      if (i===0) ctx.moveTo(sx, gy);
      else ctx.lineTo(sx, gy);
    }
    ctx.stroke();
  }
  function drawBackground(dt){
    const t = performance.now()/1000;
    const sunX = (W*0.1 + Math.sin(t*0.05)*20);
    const sunY = 90 + Math.cos(t*0.05)*6;
    const grad = ctx.createRadialGradient(sunX, sunY, 6, sunX, sunY, 60);
    grad.addColorStop(0, '#ffe27a');
    grad.addColorStop(1, 'rgba(255,226,122,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(sunX, sunY, 60, 0, Math.PI*2); ctx.fill();

    for (const c of clouds){ c.x -= speed*0.08*dt; if (c.x < -120){ c.x = W + rnd(30,120); c.y = rnd(30,160); c.s = rnd(0.7,1.3);} drawCloud(c.x, c.y, c.s); }
    ctx.fillStyle = '#7fbf6b';
    for (const h of farHills){ h.x -= speed*0.16*dt; if (h.x < -h.w){ h.x = W + rnd(40,120); h.w = rnd(220,300); h.h = rnd(46,72);} hill(h.x, BASE_GROUND+8, h.w, h.h); }
    for (const tr of trees){ tr.x -= speed*0.35*dt; if (tr.x < -40){ tr.x = W + rnd(0,200); tr.s = rnd(0.9,1.25);} drawTree(tr.x, groundYAt(tr.x), tr.s); }
    for (const b of bushes){ b.x -= speed*0.45*dt; if (b.x < -30){ b.x = W + rnd(0,120); b.s = rnd(0.8,1.2);} drawBush(b.x, groundYAt(b.x), b.s); }

    drawGroundStrip();
  }

  function draw(dt){
    ctx.clearRect(0,0,W,H);
    drawBackground(dt);
    for (const e of entities){
      if (e.kind==='ob'){
        if (e.type==='rock') drawRock(e);
        else if (e.type==='bird') drawBird(e);
      } else if (e.kind==='candy'){
        drawCandy(e);
      }
    }
    drawGiraffe();
    drawPops();
  }

  // Helpers
  function drawCloud(x,y,s){ ctx.save(); ctx.translate(x,y); ctx.scale(s,s); ctx.fillStyle = 'rgba(255,255,255,0.9)'; roundedEllipse(-30,0,40,22); roundedEllipse(-5,-12,34,20); roundedEllipse(18,0,38,24); ctx.restore(); }
  function roundedEllipse(cx,cy,rx,ry){ ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); ctx.fill(); }
  function hill(x,base,w,h){ ctx.beginPath(); ctx.moveTo(x-w/2, base); ctx.quadraticCurveTo(x, base-h, x+w/2, base); ctx.closePath(); ctx.fill(); }
  function drawTree(x,base,s){ ctx.save(); ctx.translate(x,base); ctx.scale(s,s); ctx.fillStyle = '#7a4f2b'; ctx.fillRect(-6,-46,12,46); ctx.fillStyle = '#3e864b'; ctx.beginPath(); ctx.moveTo(-28,-38); ctx.bezierCurveTo(-10,-60,10,-60,28,-38); ctx.bezierCurveTo(18,-22,-18,-22,-28,-38); ctx.fill(); ctx.beginPath(); ctx.moveTo(-24,-56); ctx.bezierCurveTo(-8,-76,8,-76,24,-56); ctx.bezierCurveTo(14,-44,-14,-44,-24,-56); ctx.fill(); ctx.restore(); }
  function drawBush(x,base,s){ ctx.save(); ctx.translate(x,base); ctx.scale(s,s); ctx.fillStyle = '#4fa85a'; roundedEllipse(-16,-10,18,12); roundedEllipse(0,-12,22,14); roundedEllipse(18,-10,18,12); ctx.restore(); }
  function roundRectPath(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); }
  function wingShape(x,y,w,h){ ctx.beginPath(); ctx.moveTo(x, y); ctx.quadraticCurveTo(x-w*0.3, y-h*0.4, x-w*0.9, y-h*0.1); ctx.quadraticCurveTo(x-w*0.4, y+h*0.1, x, y); ctx.fill(); }
  function paintSpot(cx,cy,rx,ry){ ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry, 0.25, 0, Math.PI*2); ctx.fill(); }
  function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
})();
</script>
</body>
</html>
